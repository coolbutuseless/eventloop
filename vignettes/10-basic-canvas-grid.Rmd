---
title: "Basic Canvas"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Basic Canvas}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## A simple drawing canvas

* A standard R matrix is used to store 0/1 values which will be displayed as
  black/white tiles
* Left/Right mouse are used to activate drawing in black/white respectively
* Pressing SPACE will clear the canvas



## Event Loop Considerations

* The world does not update every frame, but only when the user interacts.
  This slow rate of change means that double buffering can be disabled for this example
  and there is little chance of screen tearing or flickering during updates.
* By disabling double-buffering, this also avoids the mouse icon flickering
  as the device switches between hold/flush operations.  This change-of-state
  of the mouse icon for every drawing operation is baked into R and will
  always be present for double-buffered presentation.



```{r setup, eval=FALSE}
library(grid)
library(eventloop)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Set up the global variables which store the state of the world
#   N      size of grid
#  canvas  the actual canvas
#  pen     the current pen state. Use 'NA' to indicate "not drawing"
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N      <- 8
canvas <- matrix(1L, N, N)
pen    <- NA_integer_


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#' The main 'draw' function called within the eventloop
#' 
#' Press ESC to quit..
#'
#' If 'event' is not NULL, then it means that the user interacted with the
#' display.  The following events have an effect on the canvas:
#'  - left/right mouse click sets the pen colour to black/white respectively
#'  - releasing the mouse button stops drawing mode
#'  - pressing SPACE clears the canvas
#'
#' @param event The event from the graphics device. Is NULL when no event
#'        occurred.  Otherwise has `type` element set to:
#'        `event$type = 'mouse_down'` 
#'               - an event in which a mouse button was pressed
#'               - `event$button` gives the index of the button
#'        `event$type = 'mouse_up'`   
#'               - a mouse button was released
#'        `event$type = 'key_press'`  
#'               - a key was pressed
#'               - `event$char` holds the character as string
#'               - `event$int` holds the integer representation
#' @param mouse_x,mouse_y current location of mouse within window. If mouse is 
#'        not within window, this will be set to the last available coordinates
#' @param frame_num integer count of which frame this is
#' @param fps_actual,fps_target the curent framerate and the framerate specified
#'        by the user
#' @param dev_width,dev_height the width and height of the output device. Note:
#'        this does not cope well if you resize the window
#' @param ... any extra arguments ignored
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
draw <- function(event, mouse_x, mouse_y, ...) {
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Process events
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (!is.null(event)) {
    if (event$type == 'mouse_down') {
      cat(event$button)
      if (event$button == 0) {
        pen <<- 0L
      } else if (event$button == 2) {
        pen <<- 1L
      }
    } else if (event$type == 'mouse_up') {
      pen <<- NA_integer_
    }
    
    if (event$type == 'key_press' && event$char == ' ') {
      canvas <<- matrix(1L, N, N)
      grid::grid.raster(canvas, interpolate = FALSE)
    }
  }
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # If the pen is currently active, then draw on the canvas and display
  # the latest version.
  # Note that graphics coordiates are from bottom-left of screen, while
  # matrix coordinates are from top-left.  So the y-axis must be inverted
  # to set a matrix location from a mouse position
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (!is.na(pen)) {
    col <-       round(mouse_x * N + 0.5)
    row <- N+1 - round(mouse_y * N + 0.5)
    
    canvas[row, col] <<- pen
    grid::grid.raster(canvas, interpolate = FALSE)
  }
  
  
}


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Start the event loop.  
# Press ESC to quit
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
eventloop::run_loop(draw, double_buffer = FALSE)
```


Since an interactive window cannot be captured in a vignette, a video
screen capture has been taken of the window and included below.

<video controls>
  <source src="images/basic-canvas-grid.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video> 

