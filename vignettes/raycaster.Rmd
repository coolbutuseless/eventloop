---
title: "raycaster"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{raycaster}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


```{r}
N <- 9
mat <- matrix(seq(N*N), N, N)
```


```{r setup}
library(eventloop)
library(ggplot2)
library(dplyr)
library(purrr)
library(grid)
library(magrittr)

N <- 9
set.seed(1)
mat <- matrix(sample(c(0, 1), N*N, replace = TRUE, prob = c(0.85, 0.3)), N, N)
mat[1,] <- 1
mat[N,] <- 1
mat[,1] <- 1
mat[,N] <- 1
# mat <- matrix(seq(N*N), N, N)

df <- expand.grid(y = seq(N)-0.5, x = seq(N)-0.5)
df$val <- as.vector(mat)
df$col <- ifelse(df$val == 1, 'grey70', 'white')

# angle_degs <- c(230)

start_start <- Sys.time()
for (angle_start in seq(1, 359, 3)) {

angle_degs <- (angle_start + 0:29) %% 360
angle_deg <- angle_degs[1]


speed_start <- Sys.time()
dists <- numeric(length(angle_degs))

speed_start <- Sys.time()
for (ii in seq_along(angle_degs)) {
  angle_deg <- angle_degs[ii]
  
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
x0 <- 4.7
y0 <- 3.4
theta <- angle_deg * pi/180

quadrant <- as.integer(angle_deg / 90) + 1L

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
yfrac <- 1 - (y0 - floor(y0))

dx <- 1/tan(theta)

dy    <- ifelse(quadrant %in% 1:2,     1,        -1)
yfrac <- ifelse(quadrant %in% 1:2, yfrac, 1 - yfrac)
dx    <- ifelse(quadrant %in% 1:2,    dx,       -dx)

horx = x0 + yfrac * dx + seq.int(0, 4) * dx
hory = y0 + yfrac * dy + seq.int(0, 4) * dy

idx <- horx > 0 & horx < N & hory > 0 & hory < N
horx <- horx[idx]
hory <- hory[idx]


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
xfrac <- 1 - (x0 - floor(x0))

dy <-   tan(theta)

dx    <- ifelse(quadrant %in% c(1L, 4L),     1,        -1)
xfrac <- ifelse(quadrant %in% c(1L, 4L), xfrac, 1 - xfrac)
dy    <- ifelse(quadrant %in% c(1L, 4L),    dy,       -dy)


verx = x0 + xfrac * dx + seq.int(0, 4) * dx
very = y0 + xfrac * dy + seq.int(0, 4) * dy


idx <- verx > 0 & verx < N & very > 0 & very < N
verx <- verx[idx]
very <- very[idx]

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Quadrant 1
if (quadrant == 1L) {
  hhits <- mat[cbind(hory + 1, ceiling(horx))]
  vhits <- mat[cbind(ceiling(very), verx + 1)]
} else if (quadrant == 2L) {
  # Quadrant 2
  hhits <- mat[cbind(hory + 1, ceiling(horx))]
  vhits <- mat[cbind(ceiling(very), verx)]
} else if (quadrant == 3L) {
  # Quadrant 3
  hhits <- mat[cbind(hory, ceiling(horx))]
  vhits <- mat[cbind(ceiling(very), verx)]
} else if (quadrant == 4L) {
  # Quadrant 4
  hhits <- mat[cbind(hory, ceiling(horx))]
  vhits <- mat[cbind(ceiling(very), verx + 1)]
} else {
  stop("Bad quadrant: ", quadrant)
}

hfirst <- which.max(hhits)
vfirst <- which.max(vhits)

hbestx <- horx[hfirst]
hbesty <- hory[hfirst]

vbestx <- verx[vfirst]
vbesty <- very[vfirst]

if (max(hhits, na.rm=TRUE) == 0) {
  dist <- sqrt((vbestx - x0)^2 + (vbesty - y0)^2)
} else if (max(vhits, na.rm=TRUE) == 0) {
  dist <- sqrt((hbestx - x0)^2 + (hbesty - y0)^2)
} else {
  hdist <- sqrt((hbestx - x0)^2 + (hbesty - y0)^2)
  vdist <- sqrt((vbestx - x0)^2 + (vbesty - y0)^2)
  
  dist <- min(hdist, vdist)
}

xh <- x0 + dist * cos(theta)
yh <- y0 + dist * sin(theta)

  dists[ii] <- dist

}  # End speed run
print(Sys.time() - speed_start)

dists <- dists * cos(seq(-14, 15) * pi/180)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Plot the DDA view
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
dunit <- 'cm'


filename <- sprintf("working/raycast/%03i.png", angle_start)
png(filename, width=700, height= 700)

grid.rect(gp = gpar(fill='white'))

grid.rect(x = ((30:1)/30), width = 1/30, height = (N - dists)/15, gp = gpar(col=NA, fill='blue'))


grid.rect(x = df$x, y = df$y, width = 1, height = 1, default.units = dunit,
          gp = gpar(fill = df$col, col = 'grey50'))
# grid.text(df$val,df$x, df$y, default.units = dunit, gp = gpar(col = 'grey40'))
grid.points(x0, y0, default.units = dunit)


d <- 5
x1 <- x0 + d * cos(theta - 15*pi/180)
y1 <- y0 + d * sin(theta - 15*pi/180)
grid.lines(c(x0, x1), c(y0, y1), default.units = dunit,
           gp = gpar(lty = 2))

# if (length(horx) > 0) {
# grid.points(horx, hory, default.units = dunit,
#             gp = gpar(col = 'blue'))
# }
# 
# if (length(verx) > 0) {
#   grid.points(verx, very, default.units = dunit,
#             gp = gpar(col = 'red'))
# }

# grid.lines(c(x0, xh), c(y0, yh), default.units = dunit, 
#            gp = gpar(col = 'darkgreen', lwd = 4))

invisible(dev.off())

} # angle_start

print(Sys.time() - start_start)
```






