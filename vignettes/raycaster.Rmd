---
title: "raycaster"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{raycaster}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```



```{r setup}
library(eventloop)
library(ggplot2)
library(dplyr)
library(purrr)
library(grid)
library(magrittr)


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Generate a random N*N map
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
N <- 9
set.seed(1)
map <- matrix(sample(c(0, 1), N*N, replace = TRUE, prob = c(0.85, 0.3)), N, N)

#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Ensure there are walls at each edge
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
map[1,] <- 1
map[N,] <- 1
map[,1] <- 1
map[,N] <- 1


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Data.frame representation of points so I have total control on how
# the map is rendered later
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
map_df     <- expand.grid(y = seq(N)-0.5, x = seq(N)-0.5)
map_df$val <- as.vector(map)
map_df$col <- ifelse(map_df$val == 1, 'grey70', 'white')


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# User position
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
fov <- 60


#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Raycast into a map returning a vector of distances and types
#
# @param x0,y0 user position
# @param direction viewing angle in degrees
#
# @return list(dists, types)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
raycast <- function(x0, y0, direction) {
  
  angle_deg <- direction + seq(-fov/2, fov/2, length.out = 100)
  Nangs     <- length(angle_deg)

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Calculate angle (in radians) and the quadrant this is in
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  theta_orig <- theta <- angle_deg * pi/180
  theta      <- rep(theta, each = N)
  
  quadrant <- as.integer( (angle_deg %% 360) / 90) + 1L
  quadrant <- rep(quadrant, each=N)
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Intercepts with horizontal walls
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  yfrac <- 1 - (y0 - floor(y0))
  yfrac <- rep(yfrac, N)
  
  dx <- 1/tan(theta)
  dx <- rep(dx, N)
  
  dy    <- ifelse(quadrant %in% 1:2,     1,        -1)
  yfrac <- ifelse(quadrant %in% 1:2, yfrac, 1 - yfrac)
  dx    <- ifelse(quadrant %in% 1:2,    dx,       -dx)
  
  
  mults <- yfrac + rep(seq.int(0, N-1L), times = Nangs)
  horx  <- x0 + mults * dx
  hory  <- y0 + mults * dy
  
  # If outside the boundary, then set to NA
  idx <- horx > 0 & horx < N & hory > 0 & hory < N
  horx[!idx] <- NA_real_
  hory[!idx] <- NA_real_
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Intercepts with vertical walls
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  xfrac <- 1 - (x0 - floor(x0))
  xfrac <- rep(xfrac, N)
  
  dy <- tan(theta)
  dy <- rep(dy, N)
  
  dx    <- ifelse(quadrant %in% c(1L, 4L),     1,        -1)
  xfrac <- ifelse(quadrant %in% c(1L, 4L), xfrac, 1 - xfrac)
  dy    <- ifelse(quadrant %in% c(1L, 4L),    dy,       -dy)
  
  mults <- xfrac + rep(seq.int(0, N-1L), times = Nangs)
  verx = x0 + mults * dx
  very = y0 + mults * dy
  
  # If outside the boundary, then set to NA
  idx <- verx > 0 & verx < N & very > 0 & very < N
  verx[!idx] <- NA_real_
  very[!idx] <- NA_real_
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # - Find the closest hit of the horizontal and vertical intercepts which intersect
  #     with a square containing a '1'
  # - Calculate the distance to the eye at (x0, y0)
  # - Determine whether the intersection was a horitonatl or vertical intercept
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  hhits_y <- ifelse(quadrant %in% 1:2, hory + 1, hory)
  hhits_x <- ceiling(horx)
  vhits_y <- ceiling(very)
  vhits_x <- ifelse(quadrant %in% c(1L, 4L), verx + 1, verx)
  
  hhits <- map[cbind(hhits_y, hhits_x)]
  vhits <- map[cbind(vhits_y, vhits_x)]
  
  hray <- rep(seq(Nangs), each = N)
  vray <- rep(seq(Nangs), each = N)
  
  htype <- rep(1L, length(hory))
  vtype <- rep(2L, length(very))
  
  hidx <- which(hhits == 1)
  vidx <- which(vhits == 1)
  
  
  fhorx <- horx[hidx]
  fhory <- hory[hidx]
  fhray <- hray[hidx]
  
  fverx <- verx[vidx]
  fvery <- very[vidx]
  fvray <- vray[vidx]
  
  
  x    <- c(fhorx, fverx)
  y    <- c(fhory, fvery)
  ray  <- c(fhray, fvray)
  type <- c(htype[hidx], vtype[vidx])
  
  
  raw_dists <- sqrt( (x - x0)^2 + (y - y0)^2 )
  dists     <- aggregate(raw_dists, by = list(ray = ray), min)$x
  
  sray  <- sort(ray)
  types <- type[order(ray, raw_dists)]
  types <- aggregate(types, list(ray = sray), head, 1)$x
  
  
  list(
    dists = dists,
    types = types,
    Nangs = Nangs,
    theta = theta_orig
  )
}




plot_raycast <- function(res, show_map = FALSE) {
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Plot the DDA view
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  dunit <- 'cm'
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Sky and ground
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  grid.rect(gp = gpar(fill='lightblue'))
  grid.rect(y = 0.25, height = 0.5, gp = gpar(fill = 'grey30'))
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Draw the walls
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  dists2 <- res$dists * cos(seq(-fov/2, fov/2, length.out = res$Nangs) * pi/180)
  fill <- c('#004588', '#002366')[res$types]
  grid.rect(
    x      = ((res$Nangs:1)-0.5)/res$Nangs, 
    width  = 1/res$Nangs, 
    height = (N - dists2)/15, 
    gp     = gpar(col=NA, fill=fill)
  )
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Overhead view of the map
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (show_map) {
    grid.rect(x = map_df$x, y = map_df$y, width = 1, height = 1, default.units = dunit,
              gp = gpar(fill = map_df$col, col = 'grey50', alpha = 0.5))
    grid.points(x0, y0, default.units = dunit)
    
    xh <- x0 + res$dists * cos(res$theta)
    yh <- y0 + res$dists * sin(res$theta)
    grid.polyline(
      x = c(rbind(x0, xh)), 
      y = c(rbind(y0, yh)), 
      default.units = dunit,
      gp = gpar(
        col   = 'darkgreen', 
        lwd   = 1, 
        alpha = 0.5
      ), 
      id = rep(seq(res$Nangs), each = 2)
    )
  }
}



#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Globals
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
x0  <- 4.7
y0  <- 3.4
angle <- 0



#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define the operations to be performed each loop
#
#  Standard variables defined as part of rendering framework
#  - x, y         coordinates of mouse in npc i.e. range [0, 1]
#  - X, Y         mouse coordinates in pixels
#  - width,height dimensions of window in pixels
#  - fps          frames per second in last 100 frames
#  - frame        current frame number (integer sequence starting from 1)
#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
wolf <- function() {
  grid::grid.rect(gp = grid::gpar(fill = 'black'))

  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Keyboard control Left/Right/Up
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  if (!is.null(event) && event$type == 'key') {
    if (event$char == 'Left') {
      angle <<- angle + 3.1
    } else if (event$char == 'Right') {
      angle <<- angle - 3.1
    } else if (event$char == 'Up') {
      x0 <<- x0 + cos(angle * pi/180)/10
      y0 <<- y0 + sin(angle * pi/180)/10
    } else if (event$char == 'Down') {
      x0 <<- x0 - cos(angle * pi/180)/10
      y0 <<- y0 - sin(angle * pi/180)/10
    }
  }
  
  res <- raycast(x0, y0, angle)
  plot_raycast(res, show_map = TRUE)
  
  
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  # Add 'FPS' count to window
  #~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  grid::grid.rect(x = 0, y = 0, width = 0.5, height = 0.1, gp = grid::gpar(fill = 'black'))
  grid::grid.text(
    label = paste("FPS:", round(fps)), x = 0.01, y = 0.01,
    just = c('left', 'bottom'), gp = grid::gpar(fontfamily = 'mono', cex = 2, col = 'white')
  )
}

eventloop::run_loop(wolf)


```


```{r setup}
# filename <- sprintf("working/raycast/%03i.png", angle_start)
# png(filename, width=700, height= 700)

# x11(type='dbcairo', antialias = 'none')
# dev.control(displaylist = 'inhibit')
# 
# start <- Sys.time()
# for (i in seq(0, 359)) {
#   cat(".")
#   res <- raycast(x0, y0, i)
#   dev.hold()
#   plot_raycast(res, show_map = TRUE)
#   dev.flush()
# }
# print(Sys.time() - start)


```






